package org.usfirst.frc.team1764.robot.custom.control.chassis.pid;

import org.usfirst.frc.team1764.robot.custom.control.signal.ChassisControlSignal;
import org.usfirst.frc.team1764.robot.custom.control.signal.GearboxControlSignal;
import org.usfirst.frc.team1764.robot.custom.subsystem.base.Controllable;
import org.usfirst.frc.team1764.robot.custom.subsystem.base.PIDControllable;
import org.usfirst.frc.team1764.robot.custom.subsystem.drivetrain.ControllableChassis;
import org.usfirst.frc.team1764.robot.custom.subsystem.base.PIDControllable;
import org.usfirst.frc.team1764.robot.custom.subsystem.drivetrain.ControllableChassis;

/**
 * Uses gyroscope as input and attempts to turn the robot to a target angle
 */
public class ChassisAngleController extends ChassisPIDController
{
    /*
    * determines how close the target has to be to the setpoint for onTarget() to return true */
    private static final double ANGLE_ABSOLUTE_TOLERANCE = 1;
    private double additiveLeft, additiveRight;

    public ChassisAngleController(String name, ControllableChassis<? extends Controllable<GearboxControlSignal>> target, double p, double i, double d, double f)
    {
        super(name, target, p, i, d, f);
    }

    /**
     *
     */
    @Override
    public void set(ChassisControlSignal c)
    {
        this.additiveLeft = c.getLeft();
        this.additiveRight = c.getRight();
    }

    /**
     * Configures the chassis for PID control given the gyro input
     */
    @Override
    public void init()
    {
        target.setAbsoluteTolerance(ANGLE_ABSOLUTE_TOLERANCE); // Configure the target's absolute tolerance
        /*
        Limit the speed on the target between these values to prevent overshooting and damage to motors
         Normally we would leave the output range without bounds because we wish for the end affector to reach the setpoint
         as fast as possible, in a constant time, which would mean having an output proportional to it's error, but in this case
         We don't care how long it takes to reach its target, we just want it to get there in one piece */
        //System.out.println("INITIALIZING PID CONTROL");
        target.setOutputRange(-0.15, 0.15);

        /* load percent control in because output is simply a percentage */
        target.loadLeftController("percent");
        target.loadRightController("percent");
    }

    /**
     * Reads the gyroscope from the target and feeds it into the target's PIDController input
     * @return angle read from the target's gyroscope
     */
    @Override
    public double getPIDInput()
    {
        return target.getCurrentAngle();
    }

    /**
     * Reads output generated by the angle controller and sets the target's components to use that output
     * @param output the output from the target's PIDController
     */
    @Override
    public void usePIDOutput(double output)
    {
        /* uses additive values to keep it moving forward, but adjusts them based on the output so it can turn while moving straight */
        target.setLeft(this.additiveLeft + output);
        target.setRight(this.additiveRight - output);
    }

    public static ChassisAngleController getPrototype(ControllableChassis<? extends Controllable<GearboxControlSignal>> target)
    {
        return new ChassisAngleController("angle", target, 0.024, 0, 0, 0);
    }
}
